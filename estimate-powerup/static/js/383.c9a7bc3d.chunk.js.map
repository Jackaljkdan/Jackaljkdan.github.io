{"version":3,"file":"static/js/383.c9a7bc3d.chunk.js","mappings":"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","sources":["components/SummaryDetail.tsx","hooks/useCurrentWork.ts","hooks/useElapsed.ts","hooks/useProvidedTrello.ts","hooks/useTrelloRender.ts","jk/hooks/useInit.ts","jk/noDeps.ts","pages/ListSummaryPage.tsx"],"sourcesContent":["import React from \"react\";\n\nimport { SummaryEstimate } from \"../api/estimateApi\";\nimport { useCurrentWork } from \"../hooks/useCurrentWork\";\nimport { useElapsedMinutes } from \"../hooks/useElapsed\";\nimport { If } from \"../jk/types/jsxControlStatements\";\nimport { formatMinutes } from \"../utils/timeParsing\";\nimport { formatWorkDelta } from \"../utils/workDelta\";\n\ntype Props = {\n    className?: string,\n    summary: SummaryEstimate,\n    margin?: number,\n}\n\nexport function SummaryDetail(props: Props) {\n    const summary = props.summary;\n    const currentWork = useCurrentWork();\n    const elapsedWorkMinutes = useElapsedMinutes(currentWork.value?.startDate);\n\n    if (!summary)\n        return null;\n\n    const currentSummary: SummaryEstimate = {\n        estimateMinutes: summary.estimateMinutes,\n        updatedEstimateMinutes: summary.updatedEstimateMinutes,\n        workMinutes: summary.workMinutes + elapsedWorkMinutes,\n        remainingMinutes: summary.remainingMinutes - elapsedWorkMinutes,\n        deltaMinutes: summary.deltaMinutes,\n    };\n\n    const marginMinutes = (props.margin ?? 0) > 0\n        ? props.margin! * summary.estimateMinutes\n        : 0\n    ;\n\n    const usedMarginMinutes = marginMinutes > 0 && currentSummary.deltaMinutes < 0\n        ? Math.min(- currentSummary.deltaMinutes, marginMinutes)\n        : 0\n    ;\n\n    const remainingMarginMinutes = marginMinutes - usedMarginMinutes;\n\n    const hasUpdatedEstimate = currentSummary.updatedEstimateMinutes > 0\n        && currentSummary.updatedEstimateMinutes !== currentSummary.estimateMinutes\n    ;\n\n    return (\n        <div className={props.className}>\n            <div>\n                {hasUpdatedEstimate && \"Original \"}\n                    Estimate: {formatMinutes(currentSummary.estimateMinutes + marginMinutes)}\n                <If condition={marginMinutes > 0}>\n                    {\" \"} (without margin: {formatMinutes(currentSummary.estimateMinutes)})\n                </If>\n            </div>\n            <If condition={hasUpdatedEstimate}>\n                <div>\n                    Updated Estimate: {formatMinutes(currentSummary.updatedEstimateMinutes + remainingMarginMinutes)}\n                </div>\n            </If>\n            <div>\n                Work: {formatMinutes(currentSummary.workMinutes)}\n            </div>\n            <div>\n                Remaining: {formatMinutes(currentSummary.remainingMinutes + remainingMarginMinutes)}\n                <If condition={marginMinutes > 0 && remainingMarginMinutes > 0}>\n                    {\" \"} (without margin: {formatMinutes(currentSummary.remainingMinutes)})\n                </If>\n                <If condition={remainingMarginMinutes === 0}>\n                    {\" \"} (no margin left)\n                </If>\n            </div>\n            <div>\n                {formatWorkDelta({\n                    delta: summary.deltaMinutes >= 0\n                        ? summary.deltaMinutes\n                        : summary.deltaMinutes + Math.min(-summary.deltaMinutes, remainingMarginMinutes),\n                })}\n                <If condition={usedMarginMinutes > 0}>\n                    <If condition={remainingMarginMinutes > 0}>\n                        {\" \"} (without margin {formatWorkDelta({ delta: summary.deltaMinutes })})\n                    </If>\n                    <If condition={remainingMarginMinutes === 0}>\n                        {\" \"} (no margin left)\n                    </If>\n                </If>\n            </div>\n        </div>\n    );\n}\n","import { useCallback, useEffect, useMemo, useState } from \"react\";\nimport { useQuery, useQueryClient } from \"react-query\";\n\nimport { CurrentWork, getCurrentWork, setCurrentWork } from \"../api/estimateApi\";\nimport { currentWorkChangedEvent } from \"../api/events/apiEvents\";\nimport { useInit } from \"../jk/hooks/useInit\";\nimport { Trello } from \"../types/trello\";\nimport { minutesToMs } from \"../utils/timeParsing\";\nimport { useProvidedTrello } from \"./useProvidedTrello\";\nimport { useTrelloRenderWithOptions } from \"./useTrelloRender\";\n\nconst queryKey = \"current_work\";\n\nexport function useCurrentWorkQuery(t: Trello.PowerUp.IFrame) {\n    // N.B. la query sembra che non venga cachata, penso che il motivo sia che\n    // ogni volta che viene aperta una scheda viene avviata una nuova\n    // istanza di react\n    const query = useQuery(\n        queryKey,\n        () => getCurrentWork(t),\n        {\n            staleTime: minutesToMs(2),\n            cacheTime: Infinity,\n            refetchOnMount: false,\n            refetchOnReconnect: false,\n            refetchOnWindowFocus: false,\n        },\n    );\n\n    useTrelloRenderWithOptions(t, {\n        refresh: query.refetch,\n        callImmediately: false,\n    });\n\n    useInit(() => {\n        const listener = currentWorkChangedEvent.on(query.refetch as any);\n        return () => currentWorkChangedEvent.off(listener) as any;\n    });\n\n    return query;\n}\n\nexport function useCurrentWork() {\n    const t = useProvidedTrello();\n    const queryClient = useQueryClient();\n    const query = useCurrentWorkQuery(t);\n    const [isSaving, setIsSaving] = useState(false);\n\n    // console.log(\"query stale: \" + query.isStale);\n\n    const set = useCallback(\n        async (updated: CurrentWork | null) => {\n            setIsSaving(true);\n            await setCurrentWork(t, updated);\n            // console.log(\"setting query data\");\n            queryClient.setQueryData(queryKey, updated);\n            setIsSaving(false);\n        },\n        [t, queryClient],\n    );\n\n    return useMemo(\n        () => ({\n            value: query.data,\n            isSaving,\n            set,\n        }),\n        [query.data, isSaving, set],\n    );\n}\n","import { useEffect, useState } from \"react\";\nimport { getElapsedMs } from \"../utils/dateMath\";\n\nexport function useElapsedMinutes(startDate: Date | undefined) {\n    return useElapsedMs(startDate) / 1000 / 60;\n}\n\nexport function useElapsedSeconds(startDate: Date | undefined) {\n    return useElapsedMs(startDate) / 1000;\n}\n\nexport function useElapsedMs(startDate: Date | undefined) {\n    const [ms, setMs] = useState(0);\n\n    useEffect(\n        () => {\n            if (startDate === undefined) {\n                setMs(0);\n                return;\n            }\n\n            let animationFrameId: number;\n            let canceled = false;\n\n            function updateSeconds() {\n                setMs(getElapsedMs(startDate!));\n\n                if (!canceled)\n                    animationFrameId = requestAnimationFrame(updateSeconds);\n            }\n\n            animationFrameId = requestAnimationFrame(updateSeconds);\n\n            return () => {\n                canceled = true;\n                cancelAnimationFrame(animationFrameId);\n            };\n        },\n        [startDate],\n    );\n\n    return ms;\n}\n","import { Trello } from \"../types/trello\";\n\nlet t: Trello.PowerUp.IFrame;\n\nexport function useProvidedTrello() {\n    if (t === undefined) {\n        t = window.TrelloPowerUp.iframe({\n            appName: process.env.REACT_APP_POWERUP_NAME,\n            appKey: process.env.REACT_APP_POWERUP_APP_KEY,\n        });\n    }\n\n    return t;\n}\n","import { Trello } from \"../types/trello\";\nimport { useInit } from \"../jk/hooks/useInit\";\nimport { useProvidedTrello } from \"./useProvidedTrello\";\n\nexport type TrelloRenderOptions = {\n    refresh: () => void;\n    callImmediately?: boolean;\n}\n\nexport function useTrelloRenderWithOptions(t: Trello.PowerUp.IFrame, options: TrelloRenderOptions) {\n    useInit(() => {\n        if (options.callImmediately)\n            options.refresh();\n        t.render(options.refresh);\n    });\n}\n\nexport function useTrelloRender(t: Trello.PowerUp.IFrame, refresh: () => void) {\n    return useTrelloRenderWithOptions(t, {\n        refresh,\n        callImmediately: true,\n    });\n}\n\nexport function useProvidedTrelloRender(refresh: () => void) {\n    const t = useProvidedTrello();\n    return useTrelloRender(t, refresh);\n}\n","import React, { useEffect } from \"react\";\nimport { noDeps } from \"../noDeps\";\n\nexport function useInit(effect: React.EffectCallback) {\n    return useEffect(effect, noDeps);\n}\n","export const noDeps = [];\n","import React, { useState } from \"react\";\r\n\r\nimport { getListEstimates, SummaryEstimate } from \"../api/estimateApi\";\r\nimport { SummaryDetail } from \"../components/SummaryDetail\";\r\nimport { useProvidedTrello } from \"../hooks/useProvidedTrello\";\r\nimport { useInit } from \"../jk/hooks/useInit\";\r\n\r\nexport default function ListSummaryPage() {\r\n    const t = useProvidedTrello();\r\n\r\n    const [listName, setListName] = useState(\"\");\r\n    const [summary, setSummary] = useState<SummaryEstimate>();\r\n\r\n    useInit(() => {\r\n        (async () => {\r\n            const trelloList = await t.list(\"id\", \"name\");\r\n            setListName(trelloList.name);\r\n            const listSummary = await getListEstimates(t);\r\n            setSummary(listSummary);\r\n        })();\r\n    });\r\n\r\n    if (!summary)\r\n        return (<div>Loading...</div>);\r\n\r\n    return (\r\n        <div>\r\n            <p>\r\n                Summary for list: {listName}\r\n            </p>\r\n            <SummaryDetail summary={summary} />\r\n        </div>\r\n    );\r\n}\r\n"],"names":["SummaryDetail","props","summary","currentWork","useCurrentWork","elapsedWorkMinutes","useElapsedMinutes","value","startDate","currentSummary","estimateMinutes","updatedEstimateMinutes","workMinutes","remainingMinutes","deltaMinutes","marginMinutes","margin","usedMarginMinutes","Math","min","remainingMarginMinutes","hasUpdatedEstimate","className","formatMinutes","formatWorkDelta","delta","queryKey","t","useProvidedTrello","queryClient","useQueryClient","query","useQuery","getCurrentWork","staleTime","minutesToMs","cacheTime","Infinity","refetchOnMount","refetchOnReconnect","refetchOnWindowFocus","useTrelloRenderWithOptions","refresh","refetch","callImmediately","useInit","listener","currentWorkChangedEvent","useCurrentWorkQuery","useState","isSaving","setIsSaving","set","useCallback","updated","setCurrentWork","setQueryData","useMemo","data","useElapsedMs","ms","setMs","useEffect","undefined","animationFrameId","canceled","requestAnimationFrame","updateSeconds","getElapsedMs","cancelAnimationFrame","window","TrelloPowerUp","iframe","appName","process","appKey","options","render","useTrelloRender","effect","noDeps","ListSummaryPage","listName","setListName","setSummary","list","trelloList","name","getListEstimates","listSummary"],"sourceRoot":""}